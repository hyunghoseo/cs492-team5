/*
  Hyungho Seo, Ryan Edelstein
  We pledge our honor that we have abided by the Stevens Honor System.
*/

#include <stdlib.h>
#include <sys/time.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>	

pthread_mutex_t queue_mutex;
pthread_cond_t condc, condp;

// Queue variables
int queue_capacity;
int queue_size = 0;
int queue_front = 0;
int queue_rear = -1;

// Variables to keep track of number of products produced/consumed
int num_produced = 0;
int num_consumed = 0;
int max_num_prod;

int quantum;

struct product {
    int prod_id, life;
    double time_stamp;
};

struct product *prod_queue;

int fn(int n)
{
    if (n <= 1)      
        return n;
    return fn(n-1) + fn(n-2);
}

double getTimeStamp() {
    struct timeval  tv;
    gettimeofday(&tv, NULL);
    double time_in_mill =
        (tv.tv_sec) * 1000 + (tv.tv_usec) / 1000 ; // convert tv_sec & tv_usec to millisecond
    return time_in_mill;
}

int queueIsEmpty() {
    return queue_size == 0;
}

int queueIsFull() {
    printf("QUEUE: %d/%d\n", queue_size, queue_capacity);
    return queue_size == queue_capacity;
}

void insertProd(struct product my_prod) {
    if (queueIsFull()) {
        printf("Trying to insert when queue is full.");
        return;
    }
    queue_rear = (queue_rear + 1)%queue_capacity;
    prod_queue[queue_rear] = my_prod;
    queue_size++;
}

struct product removeProd() {
    struct product my_prod = prod_queue[queue_front];
    queue_front = (queue_front + 1)%queue_capacity;
    queue_size--;
    return my_prod;
}

struct product createProd() {
    struct product my_prod;
    
    my_prod.prod_id = num_produced+1;
    my_prod.time_stamp = getTimeStamp();
    my_prod.life = random()%1024;

    return my_prod;
}

int main(int argc, char* argv[]) {
    // Check that there is a proper amount of parameters
    if (argc != 8) {
        printf("7 parameters required.\n");
        return -1;
    }
    
    int i;

    // P1: Number of producer threads
    int num_pro = atoi(argv[1]);
    // P2: Number of consumer threads
    int num_con = atoi(argv[2]);
    // P3: Total number of products to be generated by all producer threads
    max_num_prod = atoi(argv[3]);
    // P4: Size of the queue to store products for both producer and consumer threads
    queue_capacity = atoi(argv[4]);
    // P5: 0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for
    // Round-Robin
    int sched_alg = atoi(argv[5]);
    // P6: Value of quantum used for round-robin scheduling
    quantum = atoi(argv[6]);
    // P7: Seed for random number generator
    int seed = atoi(argv[7]);
    
    // Initialize the queue
    prod_queue = malloc(sizeof(struct product)*queue_capacity);

    // If scheduling algorithm is FCFS, set quantum to 1024
    if (sched_alg == 0)
        quantum = 1024;

    // Seed the random generator
    srandom(seed);

    // Initialize the mutex and condition variables
    pthread_mutex_init(&queue_mutex, NULL);
    pthread_cond_init(&condc, NULL);
    pthread_cond_init(&condp, NULL);

    // Initialize thread arrays
    pthread_t pro_thread[num_pro];
    pthread_t con_thread[num_con];

    // Initialize producer/consumer ID arrays
    int pn[num_pro];
    int cn[num_con];

    void *producer();
    void *consumer();

    // Create the producer/consumer threads
    for (i = 0; i < num_pro; i++) {
        pn[i] = i+1;
        pthread_create(&pro_thread[i],NULL,producer,&pn[i]);   
    }
    for (i = 0; i < num_con; i++) {
        cn[i] = i+1;
        pthread_create(&con_thread[i],NULL,consumer,&cn[i]);   
    }
    
    // Join the threads
    for (i = 0; i < num_pro; i++) {
        pthread_join(pro_thread[i],NULL);
    }
    printf("THE PRODUCERS HAVE FINISHED.\n");
    for (i = 0; i < num_con; i++) {
        pthread_join(con_thread[i],NULL);
    }

    // Destroy the mutex and condition variables
    pthread_mutex_destroy(&queue_mutex);
    pthread_cond_destroy(&condc);
    pthread_cond_destroy(&condp);

    pthread_exit(0);
}

void *producer(int *id) {
    while (num_produced < max_num_prod) {
        pthread_mutex_lock(&queue_mutex);
        
        while (queueIsFull())
            pthread_cond_wait(&condp, &queue_mutex);

        if (num_produced < max_num_prod) {
            struct product new_prod = createProd();
            insertProd(new_prod);
            num_produced++;
            printf("Producer %d has produced product %d.\n", *id, new_prod.prod_id);
        }
        
        // Wake up a consumer
        pthread_cond_signal(&condc);

        // Release the buffer
        pthread_mutex_unlock(&queue_mutex);

        // Sleep for 100 milliseconds
        usleep(100000);
    }
    pthread_exit(0);
}

void *consumer(int *id) {
    int i;
    
    while (num_consumed < max_num_prod) {
        pthread_mutex_lock(&queue_mutex);
        
        while (queueIsEmpty())
            pthread_cond_wait(&condc, &queue_mutex);

        struct product removed_prod = removeProd();

        if (num_consumed < max_num_prod) {
            if (removed_prod.life > quantum) {
                removed_prod.life = removed_prod.life - quantum;
                for (i = quantum; i > 0; i--)
                    fn(10);

                insertProd(removed_prod);
            }
            else {
                for (i = removed_prod.life; i > 0; i--)
                    fn(10);
                
                num_consumed++;

                printf("Consumer %d has consumed product %d.\n", *id, removed_prod.prod_id);
            }
        }
        
        // Wake up a producer
        pthread_cond_signal(&condp);

        pthread_mutex_unlock(&queue_mutex);

        usleep(100000);
    }
    pthread_exit(0);
}
