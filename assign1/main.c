/*
  Hyungho Seo, Ryan Edelstein
  We pledge our honor that we have abided by the Stevens Honor System.
*/

#include <stdlib.h>
#include <sys/time.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>

// Declare mutex and condition variables
pthread_mutex_t queue_mutex;
pthread_cond_t condc, condp;

// Queue variables
int queue_capacity;
int queue_size = 0;
int queue_front = 0;
int queue_rear = -1;

// Variables to keep track of number of products produced/consumed
int num_produced = 0; // number of products produced
int num_consumed = 0; // number of products consumed
int max_num_prod;

int quantum; // The quantum for the round robin scheduling algorithm

// Struct for the product
typedef struct Product {
    int prod_id, life;
    double create_time, wait_time, insert_time;
} product;

// Declare the queue as an array of products
product *prod_queue;

// Variables to track stats for turn-around times and wait times
double min_turn=100000, max_turn=0, total_turn=0,
       min_wait=100000, max_wait=0, total_wait=0;

// The Fibonacchi function
int fn(int n)
{
    if (n <= 1)
        return n;
    return fn(n-1) + fn(n-2);
}

// Function to retrieve the time stamp
double getTimeStamp() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    double time_in_mill =
        (tv.tv_sec) * 1000 + (tv.tv_usec) / 1000.0;
    return time_in_mill;
}

// Function to insert product into the rear of the queue
void insertProd(product my_prod) {
    queue_rear = (queue_rear + 1)%queue_capacity;
    prod_queue[queue_rear] = my_prod;
    queue_size++;
}

// Function to remove a product from the front of the queue and return it
product removeProd() {
    product my_prod = prod_queue[queue_front];
    queue_front = (queue_front + 1)%queue_capacity;
    queue_size--;
    return my_prod;
}

// Function to create a product and return it
product createProd() {
    product my_prod;
    
    my_prod.prod_id = num_produced+1;
    my_prod.life = random()%1024;
    my_prod.create_time = my_prod.insert_time = getTimeStamp();
    my_prod.wait_time = 0;

    return my_prod;
}

int main(int argc, char* argv[]) {
    // Check that there is a proper amount of parameters
    if (argc != 8) {
        printf("7 parameters required.\n");
        return -1;
    }
    
    int i;

    // P1: Number of producer threads
    int num_pro = atoi(argv[1]);
    // P2: Number of consumer threads
    int num_con = atoi(argv[2]);
    // P3: Total number of products to be generated by all producer threads
    max_num_prod = atoi(argv[3]);
    // P4: Size of the queue to store products for both producer and consumer threads
    queue_capacity = atoi(argv[4]);
    // P5: 0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for
    // Round-Robin
    int sched_alg = atoi(argv[5]);
    // P6: Value of quantum used for round-robin scheduling
    quantum = atoi(argv[6]);
    // P7: Seed for random number generator
    int seed = atoi(argv[7]);
    
    // Initialize the queue
    prod_queue = malloc(sizeof(product)*queue_capacity);

    // If scheduling algorithm is FCFS, set quantum to 1024,
    // which will allow the RR algorithm to act as FCFS since 1024
    // is greater than the life of any product
    if (sched_alg == 0)
        quantum = 1024;

    // Seed the random generator
    srandom(seed);

    // Initialize the mutex and condition variables
    pthread_mutex_init(&queue_mutex, NULL);
    pthread_cond_init(&condc, NULL);
    pthread_cond_init(&condp, NULL);

    // Initialize thread arrays
    pthread_t pro_thread[num_pro];
    pthread_t con_thread[num_con];

    // Initialize producer/consumer ID arrays
    int pn[num_pro];
    int cn[num_con];

    // Declare producer/consumer functions
    void *producer();
    void *consumer();

    // Save the start time
    double start_time = getTimeStamp();

    // Create the producer/consumer threads
    for (i = 0; i < num_pro; i++) {
        pn[i] = i+1;
        pthread_create(&pro_thread[i],NULL,producer,&pn[i]);   
    }
    for (i = 0; i < num_con; i++) {
        cn[i] = i+1;
        pthread_create(&con_thread[i],NULL,consumer,&cn[i]);   
    }
    
    // Join the producer threads
    for (i = 0; i < num_pro; i++) {
        pthread_join(pro_thread[i],NULL);
    }

    // Save the end time for the producer threads
    double pro_end_time = getTimeStamp();

    // Join the consumer threads
    for (i = 0; i < num_con; i++) {
        pthread_join(con_thread[i],NULL);
    }

    // Determine the total time
    double total_time = getTimeStamp() - start_time;

    // Print out the input parameters
    printf("\n----------------\
            \nINPUT PARAMETERS\
            \n----------------\n");
    printf("# Producers: %d\n", num_pro);
    printf("# Consumers: %d\n", num_con);
    printf("# Products: %d\n", max_num_prod);
    printf("Queue Size: %d\n", queue_capacity);
    printf("Scheduling: ");
    if (sched_alg == 0) printf("FCFS\n");
    else printf("RR (Q: %d)\n", quantum);

    // Print out the time metrics
    printf("\n----------------------------------\
            \n       PERFORMANCE ANALYSIS       \
            \n----------------------------------\n");

    printf("       Total Time  %f\n\n", total_time);

    printf("Turn-around Times  MIN: %f\n", min_turn);
    printf("                   MAX: %f\n", max_turn);
    printf("                   AVG: %f\n\n", total_turn/max_num_prod);

    printf("       Wait Times  MIN: %f\n", min_wait);
    printf("                   MAX: %f\n", max_wait);
    printf("                   AVG: %f\n\n", total_wait/max_num_prod);

    printf("Producer Throughput: %f\n", max_num_prod/((pro_end_time - start_time)/60000));
    printf("Consumer Throughput: %f\n\n", max_num_prod/(total_time/60000));

    // Destroy the mutex and condition variables
    pthread_mutex_destroy(&queue_mutex);
    pthread_cond_destroy(&condc);
    pthread_cond_destroy(&condp);

    pthread_exit(0);
}

void *producer(int *id) {
    // Keep producing until the max number of products has been produced
    while (num_produced < max_num_prod) {
        pthread_mutex_lock(&queue_mutex); // Lock the buffer
        
        // Hold the thread while the queue is full
        while (queue_size == queue_capacity && num_produced < max_num_prod)
            // Wait on the condition variable condp, which will be signalled
            // once a product has been removed from the queue
            pthread_cond_wait(&condp, &queue_mutex);

        // Check again whether the product goal has been reached before creating a product
        if (num_produced < max_num_prod) {
            product new_prod = createProd(); // Create a product
            insertProd(new_prod); // Insert the product into the queue
            num_produced++; // Increment the number of products produced
            printf("Producer %d has produced product %d.\n", *id, new_prod.prod_id);
        }
        
        pthread_cond_broadcast(&condc); // Wake up the consumers
        pthread_mutex_unlock(&queue_mutex); // Unlock the buffer
        usleep(100000); // Sleep for 100 milliseconds
    }
    pthread_exit(0);
}

void *consumer(int *id) {
    int i;
    
    // Keep consuming until the max number of products has been consumed
    while (num_consumed < max_num_prod) {
        pthread_mutex_lock(&queue_mutex); // Lock the buffer
        
        // Hold the thread while the queue is empty
        while (queue_size == 0 && num_consumed < max_num_prod)
            // Wait ont he condition variable condc, which will be signalled
            // once a product has been inserted into the queue
            pthread_cond_wait(&condc, &queue_mutex);

        // Check again whether the product goal has been reached before removing a product 
        if (num_consumed < max_num_prod) {
            // Save the time at which a product was removed from the queue
            double remove_time = getTimeStamp();
            // Remove a product from the queue
            product removed_prod = removeProd();

            // Check whether the product's life is greater than the quantum
            if (removed_prod.life > quantum) {
                // If so, deduct the quantum from the product's life
                removed_prod.life = removed_prod.life - quantum;
                // Call fn(10) 'quantum' times
                for (i = quantum; i > 0; i--) fn(10);

                // Update the product's wait_time and insert_time
                removed_prod.wait_time += remove_time - removed_prod.insert_time;
                removed_prod.insert_time = getTimeStamp();

                // Insert the product back into the queue
                insertProd(removed_prod);
            }
            else {
                // If not call fn(10) 'life' times
                for (i = removed_prod.life; i > 0; i--) fn(10);
                
                // Incrememnt the number of products consumed
                num_consumed++;

                // Update the product's wait_time
                removed_prod.wait_time += remove_time - removed_prod.insert_time;
                // Determine the product's turn-around time
                double turn_time = getTimeStamp() - removed_prod.create_time;

                // Update wait time stats
                if (removed_prod.wait_time < min_wait) min_wait = removed_prod.wait_time;
                if (removed_prod.wait_time > max_wait) max_wait = removed_prod.wait_time;
                total_wait += removed_prod.wait_time;

                // Update turn-around time stats
                if (turn_time < min_turn) min_turn = turn_time;
                if (turn_time > max_turn) max_turn = turn_time;
                total_turn += turn_time;

                printf("Consumer %d has consumed product %d.\n", *id, removed_prod.prod_id);
            }
        }
        
        pthread_cond_broadcast(&condp); // Wake up the producers
        pthread_mutex_unlock(&queue_mutex); // Unlock the buffer
        usleep(100000); // Sleep for 100 milliseconds
    }
    pthread_exit(0);
}
